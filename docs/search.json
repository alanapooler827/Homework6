[
  {
    "objectID": "better_programming.html",
    "href": "better_programming.html",
    "title": "Better Programming",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\nlapply() applies functions, like mean(), to all of the elements in a list.\nThe equivalent purrr function is map().\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = “kendall”) on each element of the list. Write code to do this below!\nlapply(X = numeric_matrix, FUN = cor, method = \"kendall\")\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\nIt gives use a cleaner/more consistent way to apply functions to objects\nPurrr has lots of helper functions to help you write compact code\n\nWhat is a side-effect function?\nA side effect function modifies some state. An example is write_csv() which creates a new csv file, or setwd(), which sets the working directory, modifying the R session.\nWhy can you name a variable ‘sd’ in a function and not cause any issues with the ‘sd’ function?\nCalling a function creates a temporary function environment, allowing variables in a function to have the same name as global variables."
  },
  {
    "objectID": "better_programming.html#task-1-conceptual-questions",
    "href": "better_programming.html#task-1-conceptual-questions",
    "title": "Better Programming",
    "section": "",
    "text": "What is the purpose of the lapply() function? What is the equivalent purrr function?\nlapply() applies functions, like mean(), to all of the elements in a list.\nThe equivalent purrr function is map().\nSuppose we have a list called my_list. Each element of the list is a numeric data frame (all columns are numeric). We want use lapply() to run the code cor(numeric_matrix, method = “kendall”) on each element of the list. Write code to do this below!\nlapply(X = numeric_matrix, FUN = cor, method = \"kendall\")\nWhat are two advantages of using purrr functions instead of the BaseR apply family?\n\nIt gives use a cleaner/more consistent way to apply functions to objects\nPurrr has lots of helper functions to help you write compact code\n\nWhat is a side-effect function?\nA side effect function modifies some state. An example is write_csv() which creates a new csv file, or setwd(), which sets the working directory, modifying the R session.\nWhy can you name a variable ‘sd’ in a function and not cause any issues with the ‘sd’ function?\nCalling a function creates a temporary function environment, allowing variables in a function to have the same name as global variables."
  },
  {
    "objectID": "better_programming.html#task-2-writing-r-functions",
    "href": "better_programming.html#task-2-writing-r-functions",
    "title": "Better Programming",
    "section": "Task 2: Writing R Functions",
    "text": "Task 2: Writing R Functions\n\nWrite a basic function that takes in a vector of responses and a vector of predictions and outputs the RMSE. If a value is missing for the vector of responses (i.e. an NA is present), allow for additional arguments to the mean() function (elipses) that removes the NA values in the computation.\n\n\ngetRMSE &lt;- function(response, predictions, ...) {\n  # find the squared errors\n  sq_errors &lt;- (response - predictions)^2\n\n  # calculate RMSE\n  RMSE &lt;- sqrt(mean(sq_errors, ...))\n  \n  return(RMSE)\n}\n\n\nTest getRMSE() with and without NA values\n\nGenerate sample data\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nTest getRMSE() function without missing values\n\ngetRMSE(resp, pred)\n\n[1] 0.9581677\n\n\nTest getRMSE() with missing values\n\n# change two values from resp to NA\nresp[1:2] &lt;- NA_real_\n\n# call getRMSE with na.rm set to true\ngetRMSE(resp, pred, na.rm = TRUE)\n\n[1] 0.9661699\n\n\n\nWrite a function called getMAE() that follows the specifications of the getRMSE() function.\n\n\ngetMAE &lt;- function(response, predictions, ...) {\n  # calculate absolute value of errors\n  errors &lt;- abs(response - predictions)\n  \n  # calculate MAE\n  MAE &lt;- mean(errors, ...)\n  \n  return(MAE)\n}\n\n\nTest getMAE() with and without missing values\n\nGenerate sample data\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nTest getMAE() without missing values\n\ngetMAE(resp, pred)\n\n[1] 0.8155776\n\n\nTest getMAE() with missing values\n\nresp[1:2] &lt;- NA_real_\n\ngetMAE(resp, pred, na.rm = TRUE)\n\n[1] 0.8241201\n\n\n\nCreate a wrapper function that can be used to get either or both metrics returned with a single function call. When returning your values, give them appropriate names. Function should:\n\n\ncheck that two numeric (atomic) vectors have been passed (consider is.vector(), is.atomic(), and is.numeric()). If not, the function should stop and print an informative message.\nreturn both metrics by default and include names. The behavior should be able to be changed using a character string of metrics to find.\n\n\nget_MAE_RMSE &lt;- function(response, predictions, metric = c('MAE', 'RMSE'), ...) {\n  # check data types for response and predictions vectors\n  if (!is.numeric(response) || !is.atomic(response))\n    stop('Response is not a numeric vector')\n  \n  if (!is.numeric(predictions) || !is.atomic(predictions))\n    stop('Response is not a numeric vector')\n  \n  # create empty list to store calculated metrics\n  result &lt;- c()\n  # check for each metric in the metric argument\n  if ('MAE' %in% metric) {\n    result['MAE'] &lt;- getMAE(response, predictions, ...)\n  }\n  \n  if ('RMSE' %in% metric) {\n    result['RMSE'] &lt;- getRMSE(response, predictions, ...)\n  }\n  return(result)\n}\n\n\nTest get_MAE_RMSE() with and without missing values\n\nGenerate sample data\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nTest function without missing values\n\nget_MAE_RMSE(resp, pred)\n\n      MAE      RMSE \n0.8155776 0.9581677 \n\n\nTest function with missing values\n\n# add missing values to resp\nresp[1:2] &lt;- NA_real_\n\n# test function\nget_MAE_RMSE(resp, pred, na.rm = TRUE)\n\n      MAE      RMSE \n0.8241201 0.9661699"
  },
  {
    "objectID": "better_programming.html#task-3-practice-with-purrr",
    "href": "better_programming.html#task-3-practice-with-purrr",
    "title": "Better Programming",
    "section": "Task 3: Practice with Purrr",
    "text": "Task 3: Practice with Purrr\nImport purrr\n\nlibrary(purrr)\n\nCreate list object\n\nlm_fit1 &lt;- lm(Sepal.Length ~ Sepal.Width + Species, data = iris)\n\n\nPull out the coefficients list element using $, coef(), and the pluck() function from purrr.\n\n\n# using $\nlm_fit1$coefficients\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n# using coef()\ncoef(lm_fit1)\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n# using pluck()\nlm_fit1 |&gt; \n  pluck(coefficients)\n\n      (Intercept)       Sepal.Width Speciesversicolor  Speciesvirginica \n        2.2513932         0.8035609         1.4587431         1.9468166 \n\n\n\nFit a number of different models with the code below!\n\n\nlm_fit2 &lt;- lm(Sepal.Length ~ Sepal.Width, data = iris)\nlm_fit3 &lt;- lm(Sepal.Length ~ Petal.Width + Sepal.Width + Species, data = iris)\nlm_fit4 &lt;- lm(Sepal.Length ~ Petal.Width + Petal.Length + Sepal.Width + Species,\ndata = iris)\nfits &lt;- list(lm_fit1, lm_fit2, lm_fit3, lm_fit4)\n\n\nUse map() to apply the confint() function to each model fit in the fits object.\n\n\nmap(fits, confint)\n\n[[1]]\n                      2.5 %   97.5 %\n(Intercept)       1.5206309 2.982156\nSepal.Width       0.5933983 1.013723\nSpeciesversicolor 1.2371791 1.680307\nSpeciesvirginica  1.7491525 2.144481\n\n[[2]]\n                2.5 %     97.5 %\n(Intercept)  5.579865 7.47258038\nSepal.Width -0.529820 0.08309785\n\n[[3]]\n                        2.5 %    97.5 %\n(Intercept)        1.74261803 3.2995285\nPetal.Width       -0.02042746 0.7635811\nSepal.Width        0.46205710 0.9343950\nSpeciesversicolor  0.44520784 1.5310516\nSpeciesvirginica   0.46412393 2.0110518\n\n[[4]]\n                       2.5 %      97.5 %\n(Intercept)        1.6182321  2.72430044\nPetal.Width       -0.6140049 -0.01630542\nPetal.Length       0.6937939  0.96469395\nSepal.Width        0.3257653  0.66601260\nSpeciesversicolor -1.1982739 -0.24885002\nSpeciesvirginica  -1.6831329 -0.36386273\n\n\n\nCreate histograms of the residuals in each model fit\n\n\n# set up 2x2 plotting window\npar(mfrow = c(2, 2))\n\n# pull out residuals using map() and create histograms\nresiduals &lt;- map(fits, resid) |&gt;\n  walk(hist)\n\n\n\n\n\n\n\n\n\nUpdate histograms to have appropriate names\n\n\n# set up 2x2 plotting window\npar(mfrow = c(2, 2))\n\n# Assign names to elements of residuals list and create histograms\nresiduals |&gt; \n  set_names(c('fit1', 'fit2', 'fit3', 'fit4')) |&gt;\n  iwalk(\\(x, names) hist(x, main = paste('Residuals for', names)))"
  }
]